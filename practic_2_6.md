# ПРАКТИЧЕСКОЕ ЗАНЯТИЕ 6

## Вспомогательные алгоритмы для некоторых процедур быстрой сортировки

Следующие три задачи имеют подготовительный характер, для последующей реализации соответствующих алгоритмов сортировки за $O(n\cdot log(n))$ операций (сортировки слияниями и быстрой сортировки Хоара), которые мы в дальнейшем ещё рассмотрим .

**Задача** 1. Написать функцию, получающую 2 отсортированных массива `A` и `B`, и объединяющую их в одном отсортированном массиве `C` `(length(C)=length(A)+length(B)=n`). Алгоритм должен иметь оценку сложности `O(n)`.
Функцию можно назвать `merge`. Реализовать 2 варианта:

а) `merge(A,B)` - возвращает массив `C`;

б) `merge!(A,B,C)` - используется внешний массив `C` (поэтому в конце имени функции и поставлен восклицательный знак).

**Задача** 2. Написать функцию, выполняющую частичную сортировку. А именно, функция получает некоторый массив `A` и некоторое значение `b`, и переставляет элементы в массивае `A` так, что бы в нём сначала шли все элементы, меньшие `b`, затем - все, равные `b`, и затем, наконец, - все большие `b`. Алгоритм должен иметь оценку сложности `O(n)`.
Реализовать следующие 2 варианта этой функции

а) c использованием 3-х вспомогательных массивов (с последующим их объединением в один);

б) без использования вспомогательного массива (все перемещения элементов должны осуществляться в переделах одного массива).

Указание для варианта б). Ввести переменные `l,m,k` и воспользоваться инвариантом цикла: `A[1:l]<b && A[l+1:m]== b && A[k+1:n]>b` `(n=length(A))`, т.е. составить цикл, реализующий этот инвариант (цикл должен завершиться, когда будет достигнуто равенство `m==k`: на каждом шаге либо `m` увеличивается на 1, либо `k` уменьшается на 1).

**Задача** 3. Написать функцию, выполняющую частичную сортировку. А именно, функция получает некоторый массив `A` и некотрое значение `b`, и переставляет элементы в массивае `A` так, что бы в нём сначала шли все элементы, меньшие или равные b, а затем, - все большие b. Алгоритм должен иметь оценку сложности `O(n)`.

## Вычисление биномиальных коэффициентов

**Задача** 4. Написать функию, для заданного натурального числа `n` возвращающую массив всех биномиальных коэффициентов порядка `n`.

Указание. Воспользоваться "треугольником" Паскаля.
(вопрос: почему формула $C_n^k=\frac{n!}{k!(n-k)!}$ при сколько-нибудь больших `n` не подходит для практических вычислений?).

Рассмотреть следующие варианты реализации вычисления биномиальных кэффициентов с использованием "треугольника" Паскаля:
а) с использованием двух массивов длины `n` (плюс-минус 1)
b) с использованием только одного массива длины `n`
г) с использованием массиванием массива длины `n/2` - это возможно с учетом свойства симметрии биномиальных коэффициентов.

## Многочлены Бернштейна

Пусть имеется некоторая числовая функция $f:[0;1]\to \mathbb{R}$, непрерывная на $[0;1]$. Многочленом Бернштейна порядка `n` для функции $f$, называетяся многочлен вида
$$
B_n(x)=\sum_{k=0}^{n}f(n/k)C_n^kx^k(1-x)^{n-k},
$$
при этом многочлены вида
$$ 
b_{kn}=C_n^kx^k(1-x)^{n-k}, \ k=0,1,...,n
$$
называют базисными многочленами Бернштейна n-го порядка.

**Теорема**. Для любой непрерывной на $[0;1]$ функции последовательность её многчленов Бернштейна $B_n(x)$ (при n=1,2,3,...) сходится к ней равномерно на этом отрезке.

**Задача** 5. Написать функцию высшего порядка,   для заданной функции `f` возвращающую значение её многочлена Бернштейна, заданного порядка `n` в заданной точке `x`.

Указание. Для вычисления базисных функций Бернштейна вывести рекуррентную формулу, основанную на рекуррентном соотношении для биномиальных коэффициентов:
$$
C_n^k=C_{n-1}^{k-1}+C_{n-1}^{k}
$$
(в результате должен получиться фактически алгоритм де Кастельжо, описанный, например, [здесь](https://ru.wikipedia.org/wiki/Алгоритм_де_Кастельжо)).

Можно было бы и непосредственно воспользоваться результатом задачи 4, но это было бы чуть менее эффективно.

Для тестирования полученного алгоритма убедиться в справедливости сформулированноой выше теоремы путеём построения соответствующих графиков. Т.е. требуется выбрать какую-либо непрерывную на отрезке [0;1] функцию, и построить её график вместе с семейством графиков, апроксимирующих её многочленов Бернштейна порядков `1,2,3,...N` (`N` - выбрать таким, чтобы добиться требуемой наглядности).